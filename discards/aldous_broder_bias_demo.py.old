#!/usr/bin/env python3
# -*- coding: utf-8 -*-
##############################################################################
# aldous_broder_bias_demo.py - test the biased Aldous/Broder maze algorithms
# Eric Conrad
# Copyright ©2020 by Eric Conrad
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
##############################################################################
# Maintenance History:
#     13 May 2020 - Initial version
##############################################################################
"""
aldous_broder_bias_demo.py - test the biased Aldous/Broder algorithm
Copyright ©2020 by Eric Conrad
License: GNU General Public License version 3 (GNU GPLv3)

References:

    [1] Jamis Buck.  Mazes for Programmers.  2015 (Pragmatic Bookshelf).
        Book (978-1-68050-055-4).
"""

    # pylint: disable=redefined-outer-name
    #     reason: grid, m and n are standard names for these variables

from rectangular_grid import Rectangular_Grid
from aldous_broder_bias import Weighted_Aldous_Broder
from layout_graphviz import Layout
from helpers import Helper

def make_maze(m, n, maze_name, prefer):
    """create a maze"""
    grid = Rectangular_Grid(m, n, name=maze_name)
    start_cell = grid[2,3]
    start_cell.kwargs["content"] = "S"
    if prefer == "straight":
        Weighted_Aldous_Broder.straight_on(grid, start=start_cell)
    elif prefer == "right":
        Weighted_Aldous_Broder.right_on(grid, start=start_cell)
    elif prefer == "left":
        Weighted_Aldous_Broder.left_on(grid, start=start_cell,
                                       no_revisit=False)
    else:
        Weighted_Aldous_Broder.turn_on(grid, start=start_cell,
                                       no_revisit=False)
    print(grid.unicode())
    return grid

def check_maze(grid):
    """check that the maze is perfect

    We want the maze to be a spanning tree of the grid.  If v is the
    number of vertices, e the number of edges, and k the number of
    components, we want to satisfy both the following conditions:
        (1) k = 1 (the maze is connected)
        (2) v = e + 1 (every edge is a bridge, given k=1)
    Since edges are counted in the manner of Euler, we count each edge
    twice.

    Note: Loops are not counted here with multiplicity, but the
    assertion will fail (as it should) if any loops occur.
    """
    m, n = grid.rows, grid.cols
    v = m * n                             # number of vertices
    e = 0                                 # number of arcs (2e)
    for cell in grid.each():
        e += len(cell.arcs)                   # Euler counting
    k, _ = Helper.find_components(grid)
        # note: e is twice the number of edges
    assert e + 2 == 2 * v and k == 1, \
        "v=%d, 2*e=%d, k=%d - not a tree" % (v, e, k)

m, n = 5, 7

print("1. Tweaked Aldous/Broder - prefer going straight")
grid = make_maze(m, n, "AldousBroder1", "straight")
check_maze(grid)

print("2. Tweaked Aldous/Broder - prefer turning right")
grid = make_maze(m, n, "AldousBroder1", "right")
check_maze(grid)

print("3. Tweaked Aldous/Broder - prefer turning left, revisits are biased")
grid = make_maze(m, n, "AldousBroder1", "left")
check_maze(grid)

print("4. Tweaked Aldous/Broder - prefer turning, revisits are biased")
grid = make_maze(m, n, "AldousBroder1", "turn")
check_maze(grid)

# END: aldous_broder_bias_demo.py
